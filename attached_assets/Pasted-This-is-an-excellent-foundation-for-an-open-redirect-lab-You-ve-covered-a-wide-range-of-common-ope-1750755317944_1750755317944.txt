This is an excellent foundation for an open redirect lab\! You've covered a wide range of common open redirect vulnerabilities and variations, which is great for educational purposes. To make it more modern and real-world, especially incorporating elements like Grafana and OAuth, and to generally enhance the lab, here are several suggestions:

## General Enhancements for Real-World Simulation

1.  **Introduce a "Legitimate" Application Context:**

      * **User Profiles/Dashboards:** Have a simple user authentication system (even if just dummy login) where after logging in, users are redirected to their profile. This is a prime spot for `return_url` or `next` parameters.
      * **Product Pages/Search:** Imagine an e-commerce site where clicking a "back to products" or "view cart" link uses a redirect parameter.
      * **Notification/Alert System:** A system that redirects users to relevant content after they click on a notification email.

2.  **Sophisticated Whitelisting/Blacklisting:**

      * **Regex-based Whitelisting:** Implement a more robust (but still bypassable in some scenarios) regex for whitelisting allowed domains. Then, create bypasses for this.
      * **Subdomain Wildcards:** Simulate scenarios where `*.example.com` is allowed, but an attacker tries `evil.com.example.com`.
      * **Case Sensitivity/Insensitivity:** Some real-world filters might be case-sensitive, allowing bypasses like `Evil.com` if `evil.com` is blacklisted.
      * **Partial String Matches:** If a filter checks for `if "evil.com" in url:`, consider payloads like `http://not-evil.com/evil.com` or `http://safe.com#evil.com`.

3.  **URL Parsing Nuances:**

      * **`urllib.parse.urlparse` and components:** Show how attackers can manipulate different parts of a URL (scheme, netloc, path, query, fragment) to bypass incomplete parsing or validation. Your `relative-redirect` and `protocol-redirect` are good starts.
      * **Backslashes, Slashes, and Double Slashes:** You have `//evil.com` and `///evil.com`. Add `\evil.com` and `\\evil.com` for Windows path style or misconfigurations.
      * **Null Bytes (`%00`):** While less common in modern web, some older systems or misconfigurations might truncate strings at null bytes, leading to bypasses.

4.  **Error Handling and Logging:**

      * **Varied Error Messages:** Instead of just "No URL provided," have more specific error messages for different validation failures.
      * **Security Logging:** Enhance the logging to capture not just redirect attempts, but also the referrer, user agent, and detected suspicious patterns. This makes the "post-exploitation" analysis more realistic.

5.  **"Trusted" Referer/Origin Checks (and Bypasses):**

      * A common, but often flawed, defense is to check the `Referer` or `Origin` header. Create an endpoint that *attempts* to use these headers for validation, then show how they can be spoofed or bypassed.

6.  **HTTP Method Variations:**

      * While open redirects are mostly GET-based, some might occur in POST requests (e.g., a form submission that redirects based on a hidden field). Add a POST endpoint.

7.  **Client-Side Vs. Server-Side Differentiations:**

      * You have `js-redirect` and `meta-redirect`. Emphasize in the dashboard what makes them client-side and how they differ from server-side `redirect()` calls. This helps explain the impact (e.g., XSS through `javascript:` protocol).

8.  **Chain Redirects:**

      * A scenario where the first redirect goes to a "trusted" domain, which then immediately redirects to an "evil" domain. This can bypass simpler referrer checks.

## Stack-Based Scenarios (Grafana, OAuth, etc.)

This is where your lab can really shine by mimicking real-world applications.

### 1\. OAuth/OpenID Connect Flow

This is a **major** source of open redirects in the wild.

  * **Simulate an OAuth Provider (e.g., Google, Facebook):**

      * **Endpoint:** `/oauth/authorize?client_id=...&response_type=code&redirect_uri=...&scope=...&state=...`
      * **Vulnerability:** The `redirect_uri` parameter is the prime target.
          * **Lack of strict matching:** Allowing `http://app.com/callback` and `http://app.com.evil.com/callback`.
          * **Missing hostname validation:** Just checking the path.
          * **Fragment/Path bypasses:** `redirect_uri=http://app.com/callback#evil.com` or `http://app.com/callback/../evil.com`.
          * **Double encoding of `redirect_uri`:** If the OAuth provider decodes it multiple times.
      * **Setup:** You'd need a mock OAuth client application that initiates the flow to your lab's mock OAuth provider.
      * **User Consent Page:** A simple page asking the "user" to authorize the "app" to access their data, then redirecting.

  * **Simulate an OAuth Client (your Flask app):**

      * **Endpoint:** `/oauth/callback?code=...&state=...`
      * **Vulnerability:** After receiving the authorization code, the client *itself* might redirect the user based on a `state` parameter or a previously stored `return_to` URL that was vulnerable to open redirect.

### 2\. Grafana-like Dashboards

Grafana often uses `returnTo` or similar parameters for redirection after login or certain actions.

  * **Login Page Redirection:**

      * **Endpoint:** `/grafana-login?returnTo=/dashboard`
      * **Vulnerability:** A `returnTo` parameter that directly redirects after successful (or simulated) login, without proper validation.
      * **Payloads:** `javascript:alert(1)`, `//evil.com`, encoded variants.

  * **Dashboard Embedding/Sharing:**

      * Grafana allows embedding dashboards. While not directly an open redirect, consider how parameters for embedding or sharing might be misused if they involve URLs that are not strictly validated. (Less common for open redirect, more for XSS, but could be related).

### 3\. Proxy/SSO Scenarios

  * **Reverse Proxy `X-Forwarded-Host`/`X-Forwarded-For`:**

      * If your Flask app is behind a proxy that sets these headers and the application code *trusts* them for generating URLs (e.g., `url_for` based on `request.host`), you can forge these headers to control the redirect location.
      * **Endpoint:** `/proxy-redirect`
      * **Vulnerability:** `return redirect(url_for('success', _external=True))` when `request.host` is controlled by `X-Forwarded-Host`.

  * **SSO (Single Sign-On) Redirects:**

      * Similar to OAuth, SSO solutions often have a `RelayState` or `SAMLRequest`/`SAMLResponse` parameter that includes a target URL for redirection after authentication.
      * **Endpoint:** `/sso-callback?RelayState=...`
      * **Vulnerability:** Lack of validation on the `RelayState` parameter which is intended to be a URL.

### 4\. Other Software Categories

  * **File Upload/Download Redirects:**

      * Some applications might redirect users after a file upload/download, and if the "next" or "success" URL is user-controlled.
      * **Endpoint:** `/upload-success?next_url=`

  * **Payment Gateway Callbacks:**

      * After completing a payment, many systems redirect the user back to the merchant site using a `success_url` or `cancel_url` parameter. These are classic targets.
      * **Endpoint:** `/payment-complete?success_url=`

  * **Email Confirmation Links:**

      * Confirmation links often contain a `return_to` or `next` URL. While usually server-generated, a misconfiguration or templating issue could lead to it.

## Implementation Ideas for Your Flask Lab

1.  **Add `render_template` for some redirect points:** Instead of `redirect(url)` directly, have a `return render_template('vulnerable_redirect.html', url=url)`. In `vulnerable_redirect.html`, you can then use:

    ```html
    <script>window.location.href = "{{ redirect_url }}";</script>
    <meta http-equiv="refresh" content="0;url={{ redirect_url }}">
    ```

    This allows for client-side open redirects beyond just `Location` headers. (You already have `js-redirect` and `meta-redirect`, so expand on these with more nuanced templates.)

2.  **Mock a "Valid" Domain:**

      * In your `Config` class, add `VALID_DOMAIN = "yourlegitsite.com"`.
      * Then, in your bypass scenarios, check against this. For example, in `whitelist-bypass`, instead of just `yoursite.com`, use `app.config['VALID_DOMAIN']`. This makes it clear what the "trusted" domain is.

3.  **Visual Feedback on Redirects:**

      * When a redirect happens, especially a malicious one, it would be cool if your lab could "catch" it and display what happened (e.g., "Redirected to: `evil.com`. This is a vulnerable open redirect\!"). This might require an intermediate Flask route that logs the redirect before actually sending the `Location` header, or a custom `Response` class. This could be complex but would enhance the learning experience.

4.  **"Safe" Redirect Endpoints:**

      * Include examples of *correctly* implemented redirects using `url_for` or strict host/path validation, so users can compare.
      * Example:
        ```python
        @app.route('/safe-redirect')
        def safe_redirect():
            next_page = request.args.get('next')
            if next_page and urllib.parse.urlparse(next_page).netloc == request.host:
                return redirect(next_page)
            return redirect(url_for('dashboard')) # Fallback to a safe page
        ```

5.  **Docker Compose:**

      * To make it truly modern and easy to deploy, create a `docker-compose.yml` file. This would allow users to spin up the Flask app easily.
      * If you want to simulate Grafana or OAuth, you could potentially have separate Docker containers for those (even if just dummy ones) and link them.

## Example Code Snippets to Add

Here's how you might add some of these:

```python
# In Config class
class Config:
    # ... existing config ...
    VALID_APP_DOMAIN = "legitapp.com" # For whitelisting scenarios
    OAUTH_CLIENT_ID = "mock-client-id-123"
    OAUTH_AUTHORIZE_URL = "/oauth/authorize" # Internal mock OAuth endpoint

# --- New Endpoints ---

# OAuth-like Authorization Endpoint (Vulnerable)
@app.route('/oauth/authorize')
def oauth_authorize():
    client_id = request.args.get('client_id')
    redirect_uri = request.args.get('redirect_uri')
    scope = request.args.get('scope')
    state = request.args.get('state')

    if not all([client_id, redirect_uri]):
        return "Missing OAuth parameters", 400

    # Simulate basic client_id check
    if client_id != app.config['OAUTH_CLIENT_ID']:
        return "Invalid client_id", 401

    # VULNERABLE: Direct redirect_uri usage without strict validation
    # Real-world: Should match against pre-registered redirect URIs EXACTLY,
    # or at least strictly validate domain/subdomain.
    
    # Simulate user consent (optional, for realism)
    # return render_template('oauth_consent.html', redirect_uri=redirect_uri, client_id=client_id, scope=scope, state=state)

    # For now, just redirect directly with a mock code
    mock_auth_code = "mock-auth-code-xyz"
    final_redirect_url = f"{redirect_uri}?code={mock_auth_code}&state={state}"
    app.logger.info(f"OAuth redirecting to: {final_redirect_url}")
    return redirect(final_redirect_url)

# Grafana-like Login Redirect
@app.route('/grafana-login', methods=['GET', 'POST'])
def grafana_login():
    return_to = request.args.get('returnTo') or request.form.get('returnTo', '/')
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        # Simulate successful login
        if username == "admin" and password == "password":
            flash("Logged into Grafana (mock) successfully!")
            app.logger.info(f"Grafana login redirecting to: {return_to}")
            # VULNERABLE: Direct redirect after login
            return redirect(return_to)
        else:
            flash("Invalid credentials for Grafana (mock).")
            return render_template('grafana_login.html', return_to=return_to)
    
    return render_template('grafana_login.html', return_to=return_to)

# Reverse Proxy X-Forwarded-Host Vulnerability
@app.route('/proxy-redirect')
def proxy_redirect():
    # VULNERABLE: If behind a proxy and 'Host' header is not securely determined.
    # Flask's request.host by default respects X-Forwarded-Host if the proxy
    # configures it properly and Flask is setup with WSGIProxyFix.
    # In a real scenario, you'd exploit a misconfiguration where app relies on X-FH.
    # For this lab, assume it's directly used.
    
    # To demonstrate, we'll force it to take X-Forwarded-Host
    # In a real Flask app, it might be more subtle.
    host_header = request.headers.get('X-Forwarded-Host', request.host)
    
    # Construct a URL that leverages the potentially spoofed host
    # For example, redirecting to a known internal endpoint, but with external host
    # This scenario is more about SSRF if the app fetches resources, or cache poisoning.
    # For direct open redirect, it's usually when an app generates a full URL based on this.
    
    # Let's make it explicitly an open redirect via the Host header
    # If the application tries to construct a full URL for redirection or links:
    # return redirect(f"http://{host_header}/some/internal/path")
    
    # A more direct OR via Host:
    # If the app builds a URL like this based on Host:
    # e.g., if there's a "return to homepage" button that constructs a URL with request.host
    return_url = f"{request.scheme}://{host_header}/success" # Leveraging request.scheme too
    app.logger.info(f"Proxy redirect attempting to: {return_url}")
    return redirect(return_url)


# Payment Gateway Callback (Simplified)
@app.route('/payment-callback')
def payment_callback():
    status = request.args.get('status')
    return_url = request.args.get('return_url')

    if not return_url:
        return "No return URL for payment callback"

    if status == 'success':
        flash('Payment successful!')
        # VULNERABLE: Directly redirecting to the user-provided return_url
        return redirect(return_url)
    else:
        flash('Payment failed or cancelled.')
        # You could also have a 'cancel_url' here
        return redirect(return_url)

# Add corresponding entries to the 'endpoints' list in dashboard():
# {
#     'name': 'OAuth Redirect',
#     'url': '/oauth/authorize?client_id=mock-client-id-123&response_type=code&scope=profile&state=abc&redirect_uri=',
#     'description': 'Simulated OAuth authorization flow with vulnerable redirect_uri',
#     'payloads': ['http://evil.com', 'http://legitapp.com.evil.com', 'http://legitapp.com/#evil.com'],
#     'category': 'OAuth/SSO'
# },
# {
#     'name': 'Grafana Login Redirect',
#     'url': '/grafana-login?returnTo=',
#     'description': 'Login page redirect vulnerability akin to Grafana',
#     'payloads': ['http://evil.com', '//evil.com', 'javascript:alert(document.domain)'],
#     'category': 'Application Specific'
# },
# {
#     'name': 'Proxy Host Header Redirect',
#     'url': '/proxy-redirect',
#     'description': 'Exploiting X-Forwarded-Host for redirect. Requires manipulating Host/X-Forwarded-Host header.',
#     'payloads': ['Set X-Forwarded-Host to evil.com'],
#     'category': 'Header/Proxy'
# },
# {
#     'name': 'Payment Callback Redirect',
#     'url': '/payment-callback?status=success&return_url=',
#     'description': 'Vulnerable payment gateway callback URL.',
#     'payloads': ['http://evil.com', 'https://malicious.net/collect_creds'],
#     'category': 'Application Specific'
# }

# You'll also need templates for these:
# templates/grafana_login.html (simple form)
# templates/oauth_consent.html (simple consent form)
```

By adding these elements, you'll provide a much richer, more realistic, and challenging environment for learning and testing open redirect vulnerabilities in modern web applications.