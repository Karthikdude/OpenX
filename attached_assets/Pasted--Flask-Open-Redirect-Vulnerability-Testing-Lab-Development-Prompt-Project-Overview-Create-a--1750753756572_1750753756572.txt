# Flask Open Redirect Vulnerability Testing Lab Development Prompt

## Project Overview
Create a comprehensive Flask-based web application that serves as a testing laboratory for open redirect vulnerabilities. This lab should contain various vulnerable endpoints that demonstrate different types of open redirect vulnerabilities to validate the effectiveness of the OpenX scanner.

## Core Requirements

### 1. Application Structure
```
flask-redirect-lab/
├── app.py (main Flask application)
├── templates/
│   ├── base.html
│   ├── index.html
│   ├── login.html
│   ├── dashboard.html
│   └── vulnerable.html
├── static/
│   ├── css/style.css
│   └── js/main.js
├── requirements.txt
└── README.md
```

### 2. Vulnerable Endpoints Implementation

#### Basic Open Redirects
```python
# Level 1: Direct parameter redirect (most basic)
@app.route('/redirect')
def basic_redirect():
    url = request.args.get('url')
    return redirect(url)

# Level 2: Return URL redirect
@app.route('/login')
def login_redirect():
    return_url = request.args.get('return_url', '/')
    # Simulate login process
    return redirect(return_url)
```

#### Parameter Variations
Create endpoints testing different parameter names commonly used:
- `url`, `redirect`, `return`, `returnurl`, `return_url`
- `next`, `goto`, `target`, `destination`, `dest`
- `continue`, `forward`, `location`, `site`
- `redirect_uri`, `callback`, `success_url`

#### Encoding Bypass Scenarios
```python
# URL encoding variations
@app.route('/encoded-redirect')
def encoded_redirect():
    url = request.args.get('target')
    # Simulate basic URL decoding
    if url:
        decoded_url = urllib.parse.unquote(url)
        return redirect(decoded_url)

# Double encoding scenario
@app.route('/double-encoded')
def double_encoded_redirect():
    url = request.args.get('url')
    if url:
        # Double decode
        decoded = urllib.parse.unquote(urllib.parse.unquote(url))
        return redirect(decoded)
```

#### Protocol-based Bypasses
```python
# Protocol confusion
@app.route('/protocol-redirect')
def protocol_redirect():
    url = request.args.get('url')
    if url and not url.startswith('http'):
        # Vulnerable: allows javascript:, data:, etc.
        return redirect(url)
    return redirect(url)

# Relative URL handling
@app.route('/relative-redirect')
def relative_redirect():
    path = request.args.get('path', '/')
    # Vulnerable to //evil.com bypasses
    return redirect(path)
```

### 3. Filtering Bypass Scenarios

#### Whitelist Bypasses
```python
# Weak domain validation
@app.route('/whitelist-bypass')
def whitelist_bypass():
    url = request.args.get('url')
    if url and 'yoursite.com' in url:
        # Vulnerable: allows evil.com/yoursite.com
        return redirect(url)
    return "Invalid redirect URL"

# Subdomain confusion
@app.route('/subdomain-bypass')
def subdomain_bypass():
    url = request.args.get('url')
    if url and url.startswith('https://yoursite.com'):
        # Vulnerable: allows https://yoursite.com.evil.com
        return redirect(url)
    return "Invalid redirect URL"
```

#### Blacklist Bypasses
```python
# Basic blacklist
@app.route('/blacklist-bypass')
def blacklist_bypass():
    url = request.args.get('url')
    blocked = ['evil.com', 'malicious.com']
    
    if url and not any(blocked_domain in url for blocked_domain in blocked):
        # Vulnerable to encoding, subdomains, etc.
        return redirect(url)
    return "Blocked URL"
```

### 4. Advanced Vulnerability Scenarios

#### Header-based Redirects
```python
# Host header injection
@app.route('/host-redirect')
def host_redirect():
    host = request.headers.get('Host')
    return redirect(f'https://{host}/success')

# Referer-based redirect
@app.route('/referer-redirect')
def referer_redirect():
    referer = request.headers.get('Referer', '/')
    return redirect(referer)

# Custom header redirect
@app.route('/header-redirect')
def header_redirect():
    custom_redirect = request.headers.get('X-Redirect-To')
    if custom_redirect:
        return redirect(custom_redirect)
    return "No redirect header found"
```

#### JavaScript-based Redirects
```python
# JavaScript redirect injection
@app.route('/js-redirect')
def js_redirect():
    url = request.args.get('url', '/')
    # Render template with vulnerable JavaScript
    return render_template('js_redirect.html', redirect_url=url)
```

#### Meta Refresh Redirects
```python
# Meta refresh redirect
@app.route('/meta-redirect')
def meta_redirect():
    url = request.args.get('url', '/')
    return render_template('meta_redirect.html', redirect_url=url)
```

### 5. Template Examples

#### JavaScript Redirect Template (js_redirect.html)
```html
<!DOCTYPE html>
<html>
<head>
    <title>Redirecting...</title>
</head>
<body>
    <p>Redirecting to: {{ redirect_url }}</p>
    <script>
        // Vulnerable JavaScript redirect
        window.location.href = "{{ redirect_url|safe }}";
    </script>
</body>
</html>
```

#### Meta Refresh Template (meta_redirect.html)
```html
<!DOCTYPE html>
<html>
<head>
    <title>Redirecting...</title>
    <meta http-equiv="refresh" content="0; url={{ redirect_url }}">
</head>
<body>
    <p>If not redirected, <a href="{{ redirect_url }}">click here</a></p>
</body>
</html>
```

### 6. Testing Dashboard

#### Main Dashboard Features
- List all vulnerable endpoints with descriptions
- Test forms for each vulnerability type
- Real-time testing interface
- Payload suggestions for each endpoint
- Expected vs actual behavior documentation

#### Dashboard Route
```python
@app.route('/')
def dashboard():
    endpoints = [
        {
            'name': 'Basic Redirect',
            'url': '/redirect?url=',
            'description': 'Direct parameter redirect without validation',
            'payloads': ['http://evil.com', '//evil.com', 'https://evil.com']
        },
        # ... more endpoints
    ]
    return render_template('dashboard.html', endpoints=endpoints)
```

### 7. Security Headers and Configuration

#### Configurable Security
```python
# Allow disabling security headers for testing
@app.after_request
def after_request(response):
    if not app.config.get('SECURITY_HEADERS_DISABLED'):
        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        # Note: Intentionally not setting CSP for redirect testing
    return response
```

### 8. Logging and Analytics

#### Request Logging
```python
import logging

# Log all redirect attempts for analysis
@app.before_request
def log_requests():
    if request.endpoint and 'redirect' in request.endpoint:
        app.logger.info(f"Redirect attempt: {request.url} - Args: {request.args}")
```

### 9. Configuration Options

#### Environment Configuration
```python
class Config:
    # Enable/disable different vulnerability types
    ENABLE_BASIC_REDIRECTS = True
    ENABLE_HEADER_REDIRECTS = True
    ENABLE_JS_REDIRECTS = True
    
    # Security settings for testing
    SECURITY_HEADERS_DISABLED = True
    DEBUG = True
    
    # Callback URL for testing
    CALLBACK_URL = "http://callback.example.com"
```

### 10. Testing Interface Features

#### Interactive Testing
- Forms to test each vulnerability type
- Payload generator with common bypass techniques
- Real-time URL construction
- Response analysis display
- Success/failure indicators

#### API Endpoints for Automation
```python
# API endpoint for automated testing
@app.route('/api/test-redirect', methods=['POST'])
def api_test_redirect():
    data = request.get_json()
    endpoint = data.get('endpoint')
    payload = data.get('payload')
    
    # Return structured response for automated testing
    return jsonify({
        'endpoint': endpoint,
        'payload': payload,
        'vulnerable': True,  # Determine based on test
        'redirect_location': 'detected_location'
    })
```

### 11. Documentation and Help

#### Built-in Help System
- Endpoint documentation within the application
- Vulnerability explanations
- Mitigation recommendations
- Testing methodology guides

### 12. Quality Requirements

#### Code Quality
- Clean, well-commented Flask application
- Proper error handling
- Security considerations documented
- Cross-browser compatibility

#### User Experience
- Intuitive web interface
- Clear vulnerability demonstrations
- Educational content about each vulnerability type
- Easy setup and deployment instructions

## Deliverables
1. Complete Flask application with all vulnerable endpoints
2. HTML templates with proper styling
3. Requirements.txt with all dependencies
4. README.md with setup and usage instructions
5. Documentation explaining each vulnerability type
6. Docker configuration for easy deployment
7. Test cases demonstrating each vulnerability

## Testing Integration
The lab should be designed to work seamlessly with the OpenX scanner, providing:
- Clear success indicators for automated detection
- Various difficulty levels for scanner validation
- Comprehensive coverage of open redirect vulnerability types
- Realistic scenarios mimicking real-world applications